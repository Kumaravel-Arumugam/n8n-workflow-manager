{
  "name": "Job Market Analysis Engine",
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            { "name": "telegram_chat_id", "type": "number" },
            { "name": "role_name", "type": "string" }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [-800, 300],
      "id": "trigger-node",
      "name": "Analysis Trigger"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM job_postings WHERE chat_id = {{ $json.telegram_chat_id }} AND role = '{{ $json.role_name }}' ORDER BY scraped_date DESC;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [-560, 300],
      "id": "fetch-jobs-node",
      "name": "Fetch Job Postings",
      "credentials": {
        "postgres": {
          "id": "huv0oVp6gAOYZofK",
          "name": "job_market_intelligence"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict", "version": 2 },
          "conditions": [
            {
              "id": "check-data-exists",
              "leftValue": "={{ $input.all().length }}",
              "rightValue": 0,
              "operator": { "type": "number", "operation": "gt" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [-320, 300],
      "id": "data-check-node",
      "name": "Has Data?"
    },
    {
      "parameters": {
        "language": "pythonNative",
        "pythonCode": "import pandas as pd\nimport numpy as np\nimport matplotlib\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\nimport io\nimport base64\nimport re\nfrom datetime import datetime\nfrom collections import Counter\nimport json\n\n# ============================================\n# DATA EXTRACTION\n# ============================================\njobs = _items\nif not jobs:\n    return [{'error': 'No job data received', 'has_data': False, 'report_text': 'No data available', 'chart1_base64': '', 'chart2_base64': '', 'chart1_caption': '', 'chart2_caption': '', 'raw_analysis': {}}]\n\nrecords = [item.get('json', item) if isinstance(item, dict) else item for item in jobs]\ndf = pd.DataFrame(records)\n\n# Deduplicate by job_id\nif 'job_id' in df.columns:\n    original_count = len(df)\n    df = df.drop_duplicates(subset=['job_id'])\n    duplicates_removed = original_count - len(df)\nelse:\n    duplicates_removed = 0\n\ntotal_jobs = len(df)\nrole_name = df['role'].iloc[0] if 'role' in df.columns and len(df) > 0 else 'Unknown Role'\n\n# ============================================\n# SKILL & EXPERIENCE PARSING HELPERS\n# ============================================\nknown_skills = [\n    'sql', 'python', 'excel', 'tableau', 'power bi', 'data analysis', 'business analyst',\n    'data warehousing', 'data engineering', 'data quality', 'data science', 'machine learning',\n    'ai', 'google cloud platform', 'aws', 'azure', 'javascript', 'java', 'project management',\n    'process mapping', 'business models', 'business processes', 'analytical', 'analytics',\n    'advanced analytics', 'operations', 'finance', 'management', 'compliance', 'design',\n    'retail', 'wellness', 'global strategy', 'engineering management', 'channel sales',\n    'indirect sales', 'career development', 'communication', 'agile', 'scrum', 'jira',\n    'confluence', 'salesforce', 'crm', 'erp', 'sap', 'oracle', 'mysql', 'postgresql',\n    'mongodb', 'nosql', 'etl', 'api', 'json', 'xml', 'bigquery', 'snowflake', 'databricks',\n    'spark', 'hadoop', 'kafka', 'docker', 'kubernetes', 'linux', 'git', 'ci/cd', 'business operations'\n]\n\ndef parse_skills(skill_string):\n    if pd.isna(skill_string) or not str(skill_string).strip():\n        return []\n    s = str(skill_string).lower().strip()\n    found_skills = []\n    remaining = s\n    for skill in sorted(known_skills, key=len, reverse=True):\n        if skill in remaining:\n            found_skills.append(skill)\n            remaining = remaining.replace(skill, ' ')\n    leftover = [w.strip() for w in remaining.split() if len(w.strip()) > 3 and w.strip() not in ['yrs', 'years']]\n    found_skills.extend(leftover[:3])\n    return list(set(found_skills))\n\ndef parse_experience(exp_string):\n    if pd.isna(exp_string) or not str(exp_string).strip():\n        return None\n    s = str(exp_string).lower().strip()\n    match = re.search(r'(\\d+)\\s*[-‚Äì]\\s*(\\d+)', s)\n    if match:\n        return (int(match.group(1)) + int(match.group(2))) / 2\n    match = re.search(r'(\\d+)', s)\n    return int(match.group(1)) if match else None\n\n# ============================================\n# DATA QUALITY ASSESSMENT\n# ============================================\ndata_quality = {\n    'total_raw': len(records),\n    'total_unique': total_jobs,\n    'duplicates_removed': duplicates_removed,\n    'has_description': int(df['description'].notna().sum()),\n    'has_skills': int(df['skills'].notna().sum()),\n    'has_experience': int(df['experience'].notna().sum()),\n    'has_salary': int((df['salary'].notna() & (df['salary'] != '')).sum()) if 'salary' in df.columns else 0,\n    'companies_count': int(df['company'].nunique()) if 'company' in df.columns else 0,\n    'locations_count': int(df['location'].nunique()) if 'location' in df.columns else 0\n}\ndata_quality['completeness'] = round((\n    data_quality['has_description'] + \n    data_quality['has_skills'] + \n    data_quality['has_experience']\n) / (total_jobs * 3) * 100, 1) if total_jobs > 0 else 0\n\nif total_jobs >= 20 and data_quality['completeness'] >= 80:\n    quality_grade = \"HIGH\"\n    quality_desc = \"Robust dataset suitable for comprehensive analysis\"\nelif total_jobs >= 10 and data_quality['completeness'] >= 60:\n    quality_grade = \"MEDIUM\"\n    quality_desc = \"Adequate data for directional insights\"\nelse:\n    quality_grade = \"LOW\"\n    quality_desc = \"Limited data; findings are indicative only\"\n\n# ============================================\n# SKILL ANALYSIS\n# ============================================\nall_skills = []\nfor skills_str in df['skills'].dropna():\n    all_skills.extend(parse_skills(skills_str))\nskill_counts = Counter(all_skills)\ntop_skills = skill_counts.most_common(15)\ncore_skills = [s for s, c in top_skills[:5]]\nsecondary_skills = [s for s, c in top_skills[5:10]]\n\n# ============================================\n# EXPERIENCE ANALYSIS\n# ============================================\nexp_values = [parse_experience(e) for e in df['experience'].dropna()]\nexp_values = [e for e in exp_values if e is not None]\n\nexp_dist = {}\ndominant_level = \"3-5 yrs\"\nif exp_values:\n    exp_series = pd.Series(exp_values)\n    bins = [0, 2, 5, 8, 12, 25]\n    labels = ['0-2 yrs', '3-5 yrs', '6-8 yrs', '9-12 yrs', '12+ yrs']\n    exp_binned = pd.cut(exp_series, bins=bins, labels=labels, right=True)\n    exp_dist = exp_binned.value_counts().to_dict()\n    exp_dist = {str(k): int(v) for k, v in exp_dist.items() if v > 0}\n    if exp_dist:\n        dominant_level = max(exp_dist, key=exp_dist.get)\n\n# ============================================\n# ROLE CLARITY ANALYSIS\n# ============================================\ntitles = df['title'].dropna().unique().tolist()[:10]\ncompanies = df['company'].dropna().unique().tolist()[:8]\nlocations = df['location'].dropna().unique().tolist()[:5]\n\ntitle_variance = len(titles)\nif title_variance > 5:\n    title_clarity = \"LOW\"\nelif title_variance > 2:\n    title_clarity = \"MEDIUM\"\nelse:\n    title_clarity = \"HIGH\"\n\n# ============================================\n# MARKET CONSISTENCY\n# ============================================\nskill_lists = [set(parse_skills(s)) for s in df['skills'].dropna()]\nskill_lists = [s for s in skill_lists if len(s) > 0]\navg_similarity = 0\nif len(skill_lists) > 1:\n    sims = []\n    for i in range(len(skill_lists)-1):\n        intersection = len(skill_lists[i] & skill_lists[i+1])\n        union = len(skill_lists[i] | skill_lists[i+1])\n        if union > 0:\n            sims.append(intersection / union)\n    avg_similarity = float(np.mean(sims)) if sims else 0\n\nif avg_similarity > 0.4:\n    consistency = \"HIGH\"\nelif avg_similarity > 0.2:\n    consistency = \"MEDIUM\"\nelse:\n    consistency = \"LOW\"\n\n# ============================================\n# GENERATE CHARTS\n# ============================================\nchart1_base64 = \"\"\nchart2_base64 = \"\"\ncan_generate_charts = total_jobs >= 3\n\nif can_generate_charts and len(top_skills) >= 3:\n    plt.style.use(\"dark_background\")\n    bg_color, text_color = \"#0a0e1a\", \"#f0f0f0\"\n    \n    fig, ax = plt.subplots(figsize=(12, 7), dpi=150)\n    fig.patch.set_facecolor(bg_color)\n    ax.set_facecolor(bg_color)\n    \n    chart_skills = top_skills[:12]\n    skills_labels = [s[0].title() for s in chart_skills]\n    skills_values = [s[1] for s in chart_skills]\n    \n    colors = plt.cm.viridis(np.linspace(0.3, 0.9, len(skills_labels)))\n    bars = ax.barh(skills_labels[::-1], skills_values[::-1], color=colors[::-1], edgecolor='white', linewidth=0.5)\n    \n    ax.set_xlabel('Frequency', color=text_color, fontsize=12, fontweight='600')\n    ax.set_title(f'Skill Demand - {role_name}', color=text_color, fontsize=16, fontweight='bold', pad=20)\n    ax.tick_params(colors=text_color, labelsize=10)\n    ax.grid(axis='x', color='#1a1f2e', linestyle='-', linewidth=0.6, alpha=0.6)\n    \n    for bar, val in zip(bars, skills_values[::-1]):\n        ax.text(bar.get_width() + 0.3, bar.get_y() + bar.get_height()/2, str(val), va='center', color=text_color, fontsize=10)\n    \n    plt.tight_layout()\n    buffer = io.BytesIO()\n    plt.savefig(buffer, format=\"png\", bbox_inches=\"tight\", facecolor=bg_color, dpi=150)\n    buffer.seek(0)\n    chart1_base64 = base64.b64encode(buffer.read()).decode(\"utf-8\")\n    buffer.close()\n    plt.close(fig)\n\nif can_generate_charts and len(exp_dist) >= 2:\n    bg_color, text_color = \"#0a0e1a\", \"#f0f0f0\"\n    fig, ax = plt.subplots(figsize=(10, 6), dpi=150)\n    fig.patch.set_facecolor(bg_color)\n    ax.set_facecolor(bg_color)\n    \n    exp_labels = list(exp_dist.keys())\n    exp_vals = list(exp_dist.values())\n    colors = ['#00d4ff', '#00ff88', '#ffc107', '#ff6b6b', '#b388ff'][:len(exp_labels)]\n    bars = ax.bar(exp_labels, exp_vals, color=colors, edgecolor='white', linewidth=0.5)\n    \n    ax.set_xlabel('Experience Level', color=text_color, fontsize=12, fontweight='600')\n    ax.set_ylabel('Postings', color=text_color, fontsize=12, fontweight='600')\n    ax.set_title(f'Experience Distribution - {role_name}', color=text_color, fontsize=16, fontweight='bold', pad=20)\n    ax.tick_params(colors=text_color, labelsize=10)\n    ax.grid(axis='y', color='#1a1f2e', linestyle='-', linewidth=0.6, alpha=0.6)\n    \n    for bar, val in zip(bars, exp_vals):\n        ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.2, str(val), ha='center', color=text_color, fontsize=11, fontweight='bold')\n    \n    plt.tight_layout()\n    buffer = io.BytesIO()\n    plt.savefig(buffer, format=\"png\", bbox_inches=\"tight\", facecolor=bg_color, dpi=150)\n    buffer.seek(0)\n    chart2_base64 = base64.b64encode(buffer.read()).decode(\"utf-8\")\n    buffer.close()\n    plt.close(fig)\n\n# ============================================\n# PREPARE RAW ANALYSIS DATA FOR AI\n# ============================================\nraw_analysis = {\n    'role_name': role_name,\n    'total_jobs': total_jobs,\n    'data_quality': data_quality,\n    'quality_grade': quality_grade,\n    'quality_desc': quality_desc,\n    'core_skills': core_skills,\n    'secondary_skills': secondary_skills,\n    'skill_counts': dict(top_skills[:10]),\n    'experience_distribution': exp_dist,\n    'dominant_experience': dominant_level,\n    'titles': titles[:5],\n    'title_clarity': title_clarity,\n    'companies': companies[:5],\n    'locations': locations[:3],\n    'market_consistency': consistency,\n    'similarity_score': round(avg_similarity * 100, 1)\n}\n\n# ============================================\n# CHART CAPTIONS (Markdown)\n# ============================================\nchart1_caption = f\"*üìä Skill Demand - {role_name}*\\n\\n_Top skills from {total_jobs} postings._\\n\\n*Core:* {', '.join(core_skills[:3]).title()}\" if chart1_base64 else \"\"\nchart2_caption = f\"*üìà Experience Distribution - {role_name}*\\n\\n_Most demand: {dominant_level}_\" if chart2_base64 else \"\"\n\nreturn [{\n    'raw_analysis': json.dumps(raw_analysis),\n    'role_name': role_name,\n    'total_jobs': total_jobs,\n    'chart1_base64': chart1_base64,\n    'chart1_caption': chart1_caption,\n    'chart2_base64': chart2_base64,\n    'chart2_caption': chart2_caption,\n    'has_data': True\n}]\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-80, 300],
      "id": "data-processor-node",
      "name": "Data Processor (Python)"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a Job Market Intelligence Analyst. Generate a professional, informative report in Telegram-compatible Markdown format.\n\n**ANALYSIS DATA:**\n{{ $json.raw_analysis }}\n\n**INSTRUCTIONS:**\nCreate a structured report with these exact sections. Use Telegram Markdown (bold with *, italic with _, code with `).\n\n**FORMAT:**\n\n*üìä DATA QUALITY ASSESSMENT*\n\nProvide 2-3 sentences about data reliability. Include:\n- Total unique postings analyzed\n- Data completeness percentage\n- Overall quality grade (HIGH/MEDIUM/LOW)\n- What this means for the analysis reliability\n\n---\n\n*üìå SECTION A: ROLE REALITY CHECK*\n\nProvide 3-4 sentences describing:\n- What this role actually entails based on the job descriptions\n- Title clarity assessment and what it means\n- Which companies are actively hiring\n- Whether the role definition is standardized or fragmented\n\n---\n\n*üìä SECTION B: SKILL DEMAND SIGNAL*\n\nProvide 4-5 sentences covering:\n- The top 3 core skills and WHY they are essential for this role\n- Secondary skills that increase competitiveness\n- Any skill patterns or combinations that appear together\n- Practical advice on skill prioritization\n\n_üìà Skill frequency chart attached below._\n\n---\n\n*üìà SECTION C: EXPERIENCE PATTERN*\n\nProvide 3-4 sentences explaining:\n- The dominant experience level being hired\n- What this suggests about market demand (entry vs senior)\n- Whether experience requirements are realistic\n- Implications for career planning\n\n_üìà Experience distribution chart attached._\n\n---\n\n*‚öñÔ∏è SECTION D: MARKET CONSISTENCY*\n\nProvide 2-3 sentences about:\n- How standardized or fragmented the role expectations are\n- What the similarity score means practically\n- Whether employers agree on role requirements\n\n---\n\n*üéØ SECTION E: CAREER ACTION BRIEF*\n\nProvide 4-5 bullet points with actionable recommendations:\n- ‚úÖ Top 3 skills to learn immediately\n- ‚è≥ Experience level to target\n- üéØ Focus areas for job applications\n- ‚ö†Ô∏è Any caveats or limitations of this analysis\n\n---\n\n_Generated on {{ $now.format('DD-MMM-YYYY HH:mm') }} | {{ $json.total_jobs }} postings analyzed_\n\nIMPORTANT: \n- Keep it concise but informative\n- Do NOT use HTML tags\n- Use * for bold, _ for italic\n- Each section should be 2-5 sentences max\n- Be specific with numbers and percentages\n- Make insights actionable, not just descriptive",
        "options": {
          "systemMessage": "You are a professional Job Market Intelligence Analyst. Your reports are data-driven, insightful, and actionable. You write in clear, professional language that is easy to understand. Format your output in Telegram-compatible Markdown."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [200, 300],
      "id": "ai-report-generator",
      "name": "AI Report Generator"
    },
    {
      "parameters": {
        "model": "granite4:3b-h",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [200, 520],
      "id": "ollama-model",
      "name": "Ollama Chat Model",
      "credentials": {
        "ollamaApi": {
          "id": "zfMlbhaLKYrzoQGU",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            { "id": "report", "name": "report_text", "value": "={{ $json.output }}", "type": "string" },
            { "id": "chart1", "name": "chart1_base64", "value": "={{ $('Data Processor (Python)').item.json.chart1_base64 }}", "type": "string" },
            { "id": "chart1_caption", "name": "chart1_caption", "value": "={{ $('Data Processor (Python)').item.json.chart1_caption }}", "type": "string" },
            { "id": "chart2", "name": "chart2_base64", "value": "={{ $('Data Processor (Python)').item.json.chart2_base64 }}", "type": "string" },
            { "id": "chart2_caption", "name": "chart2_caption", "value": "={{ $('Data Processor (Python)').item.json.chart2_caption }}", "type": "string" }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [480, 300],
      "id": "prepare-output-node",
      "name": "Prepare Output"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            { "id": "no-data-text", "name": "report_text", "value": "=*üìë JOB MARKET INTELLIGENCE*\n\n*Role:* {{ $('Analysis Trigger').first().json.role_name }}\n\n‚ö†Ô∏è *No data available.*\n\nNo job postings found for this role in your database.\n\n_Run a scrape first using the main Job Market Pipeline._", "type": "string" },
            { "id": "chart1", "name": "chart1_base64", "value": "", "type": "string" },
            { "id": "chart2", "name": "chart2_base64", "value": "", "type": "string" }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-80, 500],
      "id": "no-data-node",
      "name": "No Data Report"
    },
    {
      "parameters": {
        "chatId": "={{ $('Analysis Trigger').first().json.telegram_chat_id }}",
        "text": "={{ $json.report_text }}",
        "additionalFields": { "appendAttribution": false, "parse_mode": "Markdown" }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [720, 300],
      "id": "send-report-node",
      "name": "Telegram: Send Report",
      "credentials": {
        "telegramApi": {
          "id": "YgUKoloc6u1XLWhU",
          "name": "job analyst"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict", "version": 2 },
          "conditions": [
            {
              "id": "has-chart1",
              "leftValue": "={{ $json.chart1_base64 }}",
              "rightValue": "",
              "operator": { "type": "string", "operation": "notEmpty" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [960, 240],
      "id": "has-chart1-node",
      "name": "Has Chart 1?"
    },
    {
      "parameters": {
        "operation": "toBinary",
        "sourceProperty": "chart1_base64",
        "binaryPropertyName": "chart1",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [1200, 180],
      "id": "chart1-to-file-node",
      "name": "Chart 1 to File"
    },
    {
      "parameters": {
        "operation": "sendPhoto",
        "chatId": "={{ $('Analysis Trigger').first().json.telegram_chat_id }}",
        "binaryData": true,
        "binaryPropertyName": "chart1",
        "additionalFields": { "caption": "={{ $json.chart1_caption }}", "parse_mode": "Markdown" }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [1440, 180],
      "id": "send-chart1-node",
      "name": "Telegram: Chart 1",
      "credentials": {
        "telegramApi": {
          "id": "YgUKoloc6u1XLWhU",
          "name": "job analyst"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict", "version": 2 },
          "conditions": [
            {
              "id": "has-chart2",
              "leftValue": "={{ $json.chart2_base64 }}",
              "rightValue": "",
              "operator": { "type": "string", "operation": "notEmpty" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [960, 400],
      "id": "has-chart2-node",
      "name": "Has Chart 2?"
    },
    {
      "parameters": {
        "operation": "toBinary",
        "sourceProperty": "chart2_base64",
        "binaryPropertyName": "chart2",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [1200, 340],
      "id": "chart2-to-file-node",
      "name": "Chart 2 to File"
    },
    {
      "parameters": {
        "operation": "sendPhoto",
        "chatId": "={{ $('Analysis Trigger').first().json.telegram_chat_id }}",
        "binaryData": true,
        "binaryPropertyName": "chart2",
        "additionalFields": { "caption": "={{ $json.chart2_caption }}", "parse_mode": "Markdown" }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [1440, 340],
      "id": "send-chart2-node",
      "name": "Telegram: Chart 2",
      "credentials": {
        "telegramApi": {
          "id": "YgUKoloc6u1XLWhU",
          "name": "job analyst"
        }
      }
    }
  ],
  "connections": {
    "Analysis Trigger": {
      "main": [[{ "node": "Fetch Job Postings", "type": "main", "index": 0 }]]
    },
    "Fetch Job Postings": {
      "main": [[{ "node": "Has Data?", "type": "main", "index": 0 }]]
    },
    "Has Data?": {
      "main": [
        [{ "node": "Data Processor (Python)", "type": "main", "index": 0 }],
        [{ "node": "No Data Report", "type": "main", "index": 0 }]
      ]
    },
    "Data Processor (Python)": {
      "main": [[{ "node": "AI Report Generator", "type": "main", "index": 0 }]]
    },
    "AI Report Generator": {
      "main": [[{ "node": "Prepare Output", "type": "main", "index": 0 }]]
    },
    "Prepare Output": {
      "main": [[{ "node": "Telegram: Send Report", "type": "main", "index": 0 }]]
    },
    "No Data Report": {
      "main": [[{ "node": "Telegram: Send Report", "type": "main", "index": 0 }]]
    },
    "Telegram: Send Report": {
      "main": [[
        { "node": "Has Chart 1?", "type": "main", "index": 0 },
        { "node": "Has Chart 2?", "type": "main", "index": 0 }
      ]]
    },
    "Has Chart 1?": {
      "main": [
        [{ "node": "Chart 1 to File", "type": "main", "index": 0 }],
        []
      ]
    },
    "Chart 1 to File": {
      "main": [[{ "node": "Telegram: Chart 1", "type": "main", "index": 0 }]]
    },
    "Has Chart 2?": {
      "main": [
        [{ "node": "Chart 2 to File", "type": "main", "index": 0 }],
        []
      ]
    },
    "Chart 2 to File": {
      "main": [[{ "node": "Telegram: Chart 2", "type": "main", "index": 0 }]]
    },
    "Ollama Chat Model": {
      "ai_languageModel": [[{ "node": "AI Report Generator", "type": "ai_languageModel", "index": 0 }]]
    }
  },
  "settings": { "executionOrder": "v1" },
  "staticData": null
}

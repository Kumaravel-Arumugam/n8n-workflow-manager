{
  "name": "Job Market Analysis Engine",
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            { "name": "telegram_chat_id", "type": "number" },
            { "name": "role_name", "type": "string" }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [-800, 300],
      "id": "trigger-node",
      "name": "Analysis Trigger"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM job_postings WHERE chat_id = {{ $json.telegram_chat_id }} AND role = '{{ $json.role_name }}' ORDER BY scraped_date DESC;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [-560, 300],
      "id": "fetch-jobs-node",
      "name": "Fetch Job Postings",
      "credentials": {
        "postgres": {
          "id": "huv0oVp6gAOYZofK",
          "name": "job_market_intelligence"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "loose", "version": 2 },
          "conditions": [
            {
              "id": "check-data-exists",
              "leftValue": "={{ $input.all().length }}",
              "rightValue": "0",
              "operator": { "type": "number", "operation": "gt" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [-320, 300],
      "id": "data-check-node",
      "name": "Has Data?"
    },
    {
      "parameters": {
        "language": "pythonNative",
        "pythonCode": "import pandas as pd\nimport numpy as np\nimport matplotlib\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\nimport io\nimport base64\nimport re\nfrom datetime import datetime\nfrom collections import Counter\n\n# ============================================\n# DATA EXTRACTION\n# ============================================\njobs = _items\nif not jobs:\n    return [{'error': 'No job data received', 'has_data': False, 'text_html': '<b>No data available</b>', 'chart1_base64': '', 'chart2_base64': '', 'chart1_caption': '', 'chart2_caption': ''}]\n\n# Build DataFrame\nrecords = [item.get('json', item) if isinstance(item, dict) else item for item in jobs]\ndf = pd.DataFrame(records)\ntotal_jobs = len(df)\n\n# Deduplicate by job_id\nif 'job_id' in df.columns:\n    df = df.drop_duplicates(subset=['job_id'])\n    total_jobs = len(df)\n\nrole_name = df['role'].iloc[0] if 'role' in df.columns and len(df) > 0 else 'Unknown Role'\n\n# ============================================\n# MINIMUM DATA CHECK\n# ============================================\nMIN_JOBS_FOR_CHARTS = 3\ncan_generate_charts = total_jobs >= MIN_JOBS_FOR_CHARTS\nlimitations = []\nif total_jobs < 10:\n    limitations.append(f\"Small sample size ({total_jobs} jobs). Findings are directional only.\")\n\n# ============================================\n# SKILL PARSING HELPER\n# ============================================\ndef parse_skills(skill_string):\n    \"\"\"Parse concatenated skills like 'business analystdata analysisgoogle cloud platform'\"\"\"\n    if pd.isna(skill_string) or not str(skill_string).strip():\n        return []\n    \n    s = str(skill_string).lower().strip()\n    \n    # Common skill keywords to split on\n    known_skills = [\n        'sql', 'python', 'excel', 'tableau', 'power bi', 'data analysis', 'business analyst',\n        'data warehousing', 'data engineering', 'data quality', 'data science', 'machine learning',\n        'ai', 'google cloud platform', 'aws', 'azure', 'javascript', 'java', 'project management',\n        'process mapping', 'business models', 'business processes', 'analytical', 'analytics',\n        'advanced analytics', 'operations', 'finance', 'management', 'compliance', 'design',\n        'retail', 'wellness', 'global strategy', 'engineering management', 'channel sales',\n        'indirect sales', 'career development', 'communication', 'agile', 'scrum', 'jira',\n        'confluence', 'salesforce', 'crm', 'erp', 'sap', 'oracle', 'mysql', 'postgresql',\n        'mongodb', 'nosql', 'etl', 'api', 'json', 'xml', 'bigquery', 'snowflake', 'databricks',\n        'spark', 'hadoop', 'kafka', 'docker', 'kubernetes', 'linux', 'git', 'ci/cd'\n    ]\n    \n    found_skills = []\n    remaining = s\n    \n    # Sort by length descending to match longer phrases first\n    for skill in sorted(known_skills, key=len, reverse=True):\n        if skill in remaining:\n            found_skills.append(skill)\n            remaining = remaining.replace(skill, ' ')\n    \n    # Also capture remaining words as potential skills if they're substantial\n    leftover_words = [w.strip() for w in remaining.split() if len(w.strip()) > 3]\n    found_skills.extend(leftover_words[:3])  # Limit noise\n    \n    return list(set(found_skills))\n\n# ============================================\n# EXPERIENCE PARSING HELPER\n# ============================================\ndef parse_experience(exp_string):\n    \"\"\"Parse experience like '2-5 Yrs' or '0-9 Yrs' into average years\"\"\"\n    if pd.isna(exp_string) or not str(exp_string).strip():\n        return None\n    \n    s = str(exp_string).lower().strip()\n    # Match patterns like 2-5, 0-9, 3-8\n    match = re.search(r'(\\d+)\\s*[-‚Äì]\\s*(\\d+)', s)\n    if match:\n        low, high = int(match.group(1)), int(match.group(2))\n        return (low + high) / 2\n    \n    # Single number\n    match = re.search(r'(\\d+)', s)\n    if match:\n        return int(match.group(1))\n    \n    return None\n\n# ============================================\n# SECTION A: ROLE REALITY CHECK\n# ============================================\nsection_a = \"\"\ntry:\n    descriptions = df['description'].dropna().tolist()\n    all_text = ' '.join(descriptions).lower()\n    \n    # Key action verbs\n    action_verbs = ['analyze', 'develop', 'manage', 'lead', 'coordinate', 'design', 'implement', 'support', 'create', 'optimize', 'report', 'collaborate', 'gather', 'document', 'translate', 'validate']\n    verb_counts = {v: all_text.count(v) for v in action_verbs}\n    top_verbs = sorted(verb_counts.items(), key=lambda x: x[1], reverse=True)[:5]\n    top_verbs = [(v, c) for v, c in top_verbs if c > 0]\n    \n    # Role clarity assessment\n    titles = df['title'].dropna().unique().tolist()[:10]\n    title_variance = len(titles)\n    if title_variance > 5:\n        clarity = \"LOW - High variance in job titles.\"\n    elif title_variance > 2:\n        clarity = \"MEDIUM - Some variation in titles.\"\n    else:\n        clarity = \"HIGH - Consistent titles.\"\n    \n    # Companies hiring\n    companies = df['company'].dropna().unique().tolist()[:5]\n    \n    section_a = f\"\"\"<b>üìå SECTION A: ROLE REALITY CHECK</b>\n\n<b>Role:</b> {role_name}\n<b>Postings Analyzed:</b> {total_jobs}\n<b>Companies Hiring:</b> {', '.join(companies)}\n\n<b>Dominant Tasks:</b>\n\"\"\" + '\\n'.join([f\"‚Ä¢ {v[0].capitalize()}: {v[1]}x\" for v in top_verbs[:4]]) + f\"\"\"\n\n<b>Title Clarity:</b> {clarity}\n\"\"\"\nexcept Exception as e:\n    section_a = f\"<b>üìå SECTION A: ROLE REALITY CHECK</b>\\n\\n‚ö†Ô∏è Error: {str(e)[:100]}\"\n    limitations.append(\"Section A failed.\")\n\n# ============================================\n# SECTION B: SKILL DEMAND SIGNAL\n# ============================================\nsection_b = \"\"\nchart1_base64 = \"\"\nchart1_caption = \"\"\ncore_skills = []\ntry:\n    all_skills = []\n    for skills_str in df['skills'].dropna():\n        parsed = parse_skills(skills_str)\n        all_skills.extend(parsed)\n    \n    skill_counts = Counter(all_skills)\n    top_skills = skill_counts.most_common(15)\n    \n    core_skills = [s for s, c in top_skills[:5]]\n    secondary_skills = [s for s, c in top_skills[5:10]]\n    \n    section_b = f\"\"\"<b>üìä SECTION B: SKILL DEMAND SIGNAL</b>\n\n<b>Core Skills (High Demand):</b>\n\"\"\" + '\\n'.join([f\"‚Ä¢ {s[0].title()}: {s[1]} postings\" for s in top_skills[:5]]) + f\"\"\"\n\n<b>Secondary Skills:</b>\n\"\"\" + '\\n'.join([f\"‚Ä¢ {s[0].title()}: {s[1]}\" for s in top_skills[5:10] if s[1] > 0]) + \"\"\"\n\n<i>üìà Skill frequency chart attached.</i>\n\"\"\"\n    \n    # Generate Chart\n    if can_generate_charts and len(top_skills) >= 3:\n        plt.style.use(\"dark_background\")\n        bg_color, text_color = \"#0a0e1a\", \"#f0f0f0\"\n        \n        fig, ax = plt.subplots(figsize=(12, 7), dpi=150)\n        fig.patch.set_facecolor(bg_color)\n        ax.set_facecolor(bg_color)\n        \n        chart_skills = top_skills[:12]\n        skills_labels = [s[0].title() for s in chart_skills]\n        skills_values = [s[1] for s in chart_skills]\n        \n        colors = plt.cm.viridis(np.linspace(0.3, 0.9, len(skills_labels)))\n        bars = ax.barh(skills_labels[::-1], skills_values[::-1], color=colors[::-1], edgecolor='white', linewidth=0.5)\n        \n        ax.set_xlabel('Frequency', color=text_color, fontsize=12, fontweight='600')\n        ax.set_title(f'Skill Demand - {role_name}', color=text_color, fontsize=16, fontweight='bold', pad=20)\n        ax.tick_params(colors=text_color, labelsize=10)\n        ax.grid(axis='x', color='#1a1f2e', linestyle='-', linewidth=0.6, alpha=0.6)\n        \n        for bar, val in zip(bars, skills_values[::-1]):\n            ax.text(bar.get_width() + 0.3, bar.get_y() + bar.get_height()/2, str(val), va='center', color=text_color, fontsize=10)\n        \n        plt.tight_layout()\n        buffer = io.BytesIO()\n        plt.savefig(buffer, format=\"png\", bbox_inches=\"tight\", facecolor=bg_color, dpi=150)\n        buffer.seek(0)\n        chart1_base64 = base64.b64encode(buffer.read()).decode(\"utf-8\")\n        buffer.close()\n        plt.close(fig)\n        chart1_caption = f\"<b>üìä Skill Demand - {role_name}</b>\\n\\n<i>Top skills from {total_jobs} postings.</i>\\n\\n<b>Core:</b> {', '.join(core_skills[:3]).title()}\"\n    else:\n        limitations.append(\"Skill chart: insufficient data.\")\nexcept Exception as e:\n    section_b = f\"<b>üìä SECTION B: SKILL DEMAND</b>\\n\\n‚ö†Ô∏è Error: {str(e)[:100]}\"\n    limitations.append(\"Section B failed.\")\n\n# ============================================\n# SECTION C: EXPERIENCE PATTERN\n# ============================================\nsection_c = \"\"\nchart2_base64 = \"\"\nchart2_caption = \"\"\ndominant_level = \"3-5 yrs\"\ntry:\n    exp_values = []\n    for exp_str in df['experience'].dropna():\n        parsed = parse_experience(exp_str)\n        if parsed is not None:\n            exp_values.append(parsed)\n    \n    if exp_values:\n        exp_series = pd.Series(exp_values)\n        bins = [0, 2, 5, 8, 12, 25]\n        labels = ['0-2 yrs', '3-5 yrs', '6-8 yrs', '9-12 yrs', '12+ yrs']\n        exp_binned = pd.cut(exp_series, bins=bins, labels=labels, right=True)\n        exp_dist = exp_binned.value_counts().sort_index()\n        exp_dist = exp_dist[exp_dist > 0]\n        \n        if len(exp_dist) > 0:\n            dominant_level = exp_dist.idxmax()\n        \n        section_c = f\"\"\"<b>üìà SECTION C: EXPERIENCE PATTERN</b>\n\n<b>Distribution:</b>\n\"\"\" + '\\n'.join([f\"‚Ä¢ {lvl}: {cnt} postings\" for lvl, cnt in exp_dist.items()]) + f\"\"\"\n\n<b>Dominant Level:</b> {dominant_level}\n<i>üìà Experience chart attached.</i>\n\"\"\"\n        \n        # Generate Chart\n        if can_generate_charts and len(exp_dist) >= 2:\n            bg_color, text_color = \"#0a0e1a\", \"#f0f0f0\"\n            fig, ax = plt.subplots(figsize=(10, 6), dpi=150)\n            fig.patch.set_facecolor(bg_color)\n            ax.set_facecolor(bg_color)\n            \n            colors = ['#00d4ff', '#00ff88', '#ffc107', '#ff6b6b', '#b388ff']\n            bars = ax.bar(exp_dist.index.astype(str), exp_dist.values, color=colors[:len(exp_dist)], edgecolor='white', linewidth=0.5)\n            \n            ax.set_xlabel('Experience Level', color=text_color, fontsize=12, fontweight='600')\n            ax.set_ylabel('Postings', color=text_color, fontsize=12, fontweight='600')\n            ax.set_title(f'Experience Distribution - {role_name}', color=text_color, fontsize=16, fontweight='bold', pad=20)\n            ax.tick_params(colors=text_color, labelsize=10)\n            ax.grid(axis='y', color='#1a1f2e', linestyle='-', linewidth=0.6, alpha=0.6)\n            \n            for bar, val in zip(bars, exp_dist.values):\n                ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.2, str(val), ha='center', color=text_color, fontsize=11, fontweight='bold')\n            \n            plt.tight_layout()\n            buffer = io.BytesIO()\n            plt.savefig(buffer, format=\"png\", bbox_inches=\"tight\", facecolor=bg_color, dpi=150)\n            buffer.seek(0)\n            chart2_base64 = base64.b64encode(buffer.read()).decode(\"utf-8\")\n            buffer.close()\n            plt.close(fig)\n            chart2_caption = f\"<b>üìà Experience Distribution - {role_name}</b>\\n\\n<i>Most demand: {dominant_level}</i>\"\n        else:\n            limitations.append(\"Exp chart: insufficient data.\")\n    else:\n        section_c = \"<b>üìà SECTION C: EXPERIENCE</b>\\n\\n‚ö†Ô∏è No experience data.\"\n        limitations.append(\"Experience field empty.\")\nexcept Exception as e:\n    section_c = f\"<b>üìà SECTION C: EXPERIENCE</b>\\n\\n‚ö†Ô∏è Error: {str(e)[:100]}\"\n    limitations.append(\"Section C failed.\")\n\n# ============================================\n# SECTION D: MARKET CONSISTENCY\n# ============================================\nsection_d = \"\"\ntry:\n    skill_lists = [set(parse_skills(s)) for s in df['skills'].dropna()]\n    skill_lists = [s for s in skill_lists if len(s) > 0]\n    \n    if len(skill_lists) > 1:\n        similarities = []\n        for i in range(len(skill_lists)-1):\n            intersection = len(skill_lists[i] & skill_lists[i+1])\n            union = len(skill_lists[i] | skill_lists[i+1])\n            if union > 0:\n                similarities.append(intersection / union)\n        avg_similarity = np.mean(similarities) if similarities else 0\n        \n        if avg_similarity > 0.4:\n            consistency = \"HIGH - Clear, standardized expectations.\"\n        elif avg_similarity > 0.2:\n            consistency = \"MEDIUM - Moderate variance.\"\n        else:\n            consistency = \"LOW - Highly fragmented role definition.\"\n        \n        section_d = f\"\"\"<b>‚öñÔ∏è SECTION D: MARKET CONSISTENCY</b>\n\n<b>Similarity Score:</b> {avg_similarity:.0%}\n<b>Assessment:</b> {consistency}\n\"\"\"\n    else:\n        section_d = \"<b>‚öñÔ∏è SECTION D: CONSISTENCY</b>\\n\\n‚ö†Ô∏è Insufficient data.\"\n        limitations.append(\"Consistency analysis: insufficient data.\")\nexcept Exception as e:\n    section_d = f\"<b>‚öñÔ∏è SECTION D: CONSISTENCY</b>\\n\\n‚ö†Ô∏è Error: {str(e)[:100]}\"\n    limitations.append(\"Section D failed.\")\n\n# ============================================\n# SECTION E: CAREER DECISION BRIEF\n# ============================================\nsection_e = \"\"\ntry:\n    section_e = f\"\"\"<b>üéØ SECTION E: CAREER DECISION BRIEF</b>\n\n<b>Skills to Prioritize:</b>\n\"\"\" + '\\n'.join([f\"‚úÖ {s.title()}\" for s in core_skills[:3]]) + f\"\"\"\n\n<b>Target Experience:</b> {dominant_level}\n\n<b>Limitations:</b>\n\"\"\" + ('\\n'.join([f\"‚ö†Ô∏è {l}\" for l in limitations]) if limitations else \"‚úÖ No significant limitations.\")\nexcept Exception as e:\n    section_e = f\"<b>üéØ SECTION E: CAREER BRIEF</b>\\n\\n‚ö†Ô∏è Error: {str(e)[:100]}\"\n\n# ============================================\n# ASSEMBLE FINAL REPORT\n# ============================================\nreport_text = f\"\"\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n<b>üìë JOB MARKET INTELLIGENCE</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n<b>Role:</b> {role_name}\n<b>Data Points:</b> {total_jobs} postings\n<b>Generated:</b> {datetime.now().strftime('%d-%m-%Y %H:%M')}\n\n{section_a}\n\n{section_b}\n\n{section_c}\n\n{section_d}\n\n{section_e}\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n<i>üìä Charts attached below.</i>\n\"\"\"\n\nreturn [{\n    'text_html': report_text,\n    'chart1_base64': chart1_base64,\n    'chart1_caption': chart1_caption,\n    'chart2_base64': chart2_base64,\n    'chart2_caption': chart2_caption,\n    'has_data': True\n}]\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-80, 200],
      "id": "analysis-engine-node",
      "name": "Analysis Engine (Python)"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            { "id": "no-data-text", "name": "text_html", "value": "=<b>üìë JOB MARKET INTELLIGENCE</b>\n\n<b>Role:</b> {{ $('Analysis Trigger').item.json.role_name }}\n\n‚ö†Ô∏è <b>No data available.</b>\n\nNo job postings found for this role.\n\n<i>Run a scrape first using the main pipeline.</i>", "type": "string" },
            { "id": "chart1", "name": "chart1_base64", "value": "", "type": "string" },
            { "id": "chart2", "name": "chart2_base64", "value": "", "type": "string" }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-80, 400],
      "id": "no-data-node",
      "name": "No Data Report"
    },
    {
      "parameters": {
        "chatId": "={{ $('Analysis Trigger').item.json.telegram_chat_id }}",
        "text": "={{ $json.text_html }}",
        "additionalFields": { "appendAttribution": false, "parse_mode": "HTML" }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [240, 300],
      "id": "send-report-node",
      "name": "Telegram: Send Report",
      "credentials": {
        "telegramApi": {
          "id": "YgUKoloc6u1XLWhU",
          "name": "job analyst"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "loose", "version": 2 },
          "conditions": [
            {
              "id": "has-chart1",
              "leftValue": "={{ $json.chart1_base64 }}",
              "rightValue": "",
              "operator": { "type": "string", "operation": "notEmpty" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [480, 200],
      "id": "has-chart1-node",
      "name": "Has Chart 1?"
    },
    {
      "parameters": {
        "operation": "toBinary",
        "sourceProperty": "chart1_base64",
        "binaryPropertyName": "chart1",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [720, 140],
      "id": "chart1-to-file-node",
      "name": "Chart 1 to File"
    },
    {
      "parameters": {
        "operation": "sendPhoto",
        "chatId": "={{ $('Analysis Trigger').item.json.telegram_chat_id }}",
        "binaryData": true,
        "binaryPropertyName": "chart1",
        "additionalFields": { "caption": "={{ $('Analysis Engine (Python)').item.json.chart1_caption }}", "parse_mode": "HTML" }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [960, 140],
      "id": "send-chart1-node",
      "name": "Telegram: Chart 1",
      "credentials": {
        "telegramApi": {
          "id": "YgUKoloc6u1XLWhU",
          "name": "job analyst"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "loose", "version": 2 },
          "conditions": [
            {
              "id": "has-chart2",
              "leftValue": "={{ $json.chart2_base64 }}",
              "rightValue": "",
              "operator": { "type": "string", "operation": "notEmpty" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [480, 360],
      "id": "has-chart2-node",
      "name": "Has Chart 2?"
    },
    {
      "parameters": {
        "operation": "toBinary",
        "sourceProperty": "chart2_base64",
        "binaryPropertyName": "chart2",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [720, 300],
      "id": "chart2-to-file-node",
      "name": "Chart 2 to File"
    },
    {
      "parameters": {
        "operation": "sendPhoto",
        "chatId": "={{ $('Analysis Trigger').item.json.telegram_chat_id }}",
        "binaryData": true,
        "binaryPropertyName": "chart2",
        "additionalFields": { "caption": "={{ $('Analysis Engine (Python)').item.json.chart2_caption }}", "parse_mode": "HTML" }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [960, 300],
      "id": "send-chart2-node",
      "name": "Telegram: Chart 2",
      "credentials": {
        "telegramApi": {
          "id": "YgUKoloc6u1XLWhU",
          "name": "job analyst"
        }
      }
    }
  ],
  "connections": {
    "Analysis Trigger": {
      "main": [[{ "node": "Fetch Job Postings", "type": "main", "index": 0 }]]
    },
    "Fetch Job Postings": {
      "main": [[{ "node": "Has Data?", "type": "main", "index": 0 }]]
    },
    "Has Data?": {
      "main": [
        [{ "node": "Analysis Engine (Python)", "type": "main", "index": 0 }],
        [{ "node": "No Data Report", "type": "main", "index": 0 }]
      ]
    },
    "Analysis Engine (Python)": {
      "main": [[{ "node": "Telegram: Send Report", "type": "main", "index": 0 }]]
    },
    "No Data Report": {
      "main": [[{ "node": "Telegram: Send Report", "type": "main", "index": 0 }]]
    },
    "Telegram: Send Report": {
      "main": [[
        { "node": "Has Chart 1?", "type": "main", "index": 0 },
        { "node": "Has Chart 2?", "type": "main", "index": 0 }
      ]]
    },
    "Has Chart 1?": {
      "main": [
        [{ "node": "Chart 1 to File", "type": "main", "index": 0 }],
        []
      ]
    },
    "Chart 1 to File": {
      "main": [[{ "node": "Telegram: Chart 1", "type": "main", "index": 0 }]]
    },
    "Has Chart 2?": {
      "main": [
        [{ "node": "Chart 2 to File", "type": "main", "index": 0 }],
        []
      ]
    },
    "Chart 2 to File": {
      "main": [[{ "node": "Telegram: Chart 2", "type": "main", "index": 0 }]]
    }
  },
  "settings": { "executionOrder": "v1" },
  "staticData": null
}
